'''
[ 야근 지수 ]
회사원인 수민이는 많은 일이 쌓여 있습니다. 수민이는 야근을 최소화하기 위해 남은 일의 작업량을 숫자로 메기고, 일에 대한 야근 지수를 줄이기로 결정했습니다.
야근 지수는 남은 일의 작업량을 제곱하여 더한 값을 의미합니다. 수민이는 1시간 동안 남은 일 중 하나를 골라 작업량 1만큼 처리할 수 있습니다.
수민이의 퇴근까지 남은 N 시간과 각 일에 대한 작업량이 있을 때, no_overtime 함수를 제작하여 수민이의 야근 지수를 최소화 한 결과를 출력해 주세요.
예를 들어, N=4 일 때, 남은 일의 작업량이 [4, 3, 3] 이라면 야근 지수를 최소화하기 위해 일을 한 결과는 [2, 2, 2]가 되고 
야근 지수는 2^2 + 2^2 + 2^2 = 12가 되어 12를 반환해 줍니다.
'''

'''
[ 접근방법 ]
남은 작업량의 제곱으로 야근지수를 산출하므로 남은 작업량의 최대값을 최소화 시키는 것이 중요하다. 예를 들면 10을 9로 줄일 경우, 
100을 81로 줄이므로 야근지수는 총 19만큼 감소하는데 비해 4를 3으로 줄일 경우, 줄어든 야근지수는 겨우 7이다.
따라서 최대값을 찾아 하나씩 줄이는게 문제해결의 핵심이다.

문제를 떠나서 수민이는 개발자가 아닌 것 같다. 개발자는 어차피 야근이 매일매일 반복되니깐 굳이 남은 작업량을 계산 할 필요가 없다 ㅎㅎ 기한까지 본인의 업무를
마치고 이슈 해결하고 디버깅하고 테스트하다보면 매일매일 밤낮이 없기 때문이다.

'''
def no_overtime(n, works):
    result = 0
    while n > 0 :
        works[works.index(max(works))] -= 1
        n -= 1
    return sum(list(map(lambda x : x**2, works)))

print(no_overtime(4, [4, 3, 3])) # 12
